<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3.5 组合语言的解释器 - python SICP 教程</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">SICP Python 描述 中文版</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="ch1.html">第一章 使用函数构建抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.1.html">1.1 引言</a></li><li class="chapter-item expanded "><a href="1.2.html">1.2 编程元素</a></li><li class="chapter-item expanded "><a href="1.3.html">1.3 定义新的函数</a></li><li class="chapter-item expanded "><a href="1.4.html">1.4 实践指南：函数的艺术</a></li><li class="chapter-item expanded "><a href="1.5.html">1.5 控制</a></li><li class="chapter-item expanded "><a href="1.6.html">1.6 高阶函数</a></li></ol></li><li class="chapter-item expanded "><a href="ch2.html">第二章 使用对象构建抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.1.html">2.1 引言</a></li><li class="chapter-item expanded "><a href="2.2.html">2.2 数据抽象</a></li><li class="chapter-item expanded "><a href="2.3.html">2.3 序列</a></li><li class="chapter-item expanded "><a href="2.4.html">2.4 可变数据</a></li><li class="chapter-item expanded "><a href="2.5.html">2.5 面向对象编程</a></li><li class="chapter-item expanded "><a href="2.6.html">2.6 实现类和对象</a></li><li class="chapter-item expanded "><a href="2.7.html">2.7 泛用方法</a></li></ol></li><li class="chapter-item expanded "><a href="ch3.html">第三章 计算机程序的构造和解释</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.1.html">3.1 引言</a></li><li class="chapter-item expanded "><a href="3.2.html">3.2 函数和所生成的过程</a></li><li class="chapter-item expanded "><a href="3.3.html">3.3 递归数据结构</a></li><li class="chapter-item expanded "><a href="3.4.html">3.4 异常</a></li><li class="chapter-item expanded "><a href="3.5.html" class="active">3.5 组合语言的解释器</a></li><li class="chapter-item expanded "><a href="3.6.html">3.6 抽象语言的解释器</a></li></ol></li><li class="chapter-item expanded "><a href="ch4.html">第四章 分布式和并行计算</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.1.html">4.1 引言</a></li><li class="chapter-item expanded "><a href="4.2.html">4.2 分布式系统</a></li><li class="chapter-item expanded "><a href="4.3.html">4.3 并行计算</a></li></ol></li><li class="chapter-item expanded "><a href="ch5.html">第五章 序列和协程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1.html">5.1 引言</a></li><li class="chapter-item expanded "><a href="5.2.html">5.2 隐式序列</a></li><li class="chapter-item expanded "><a href="5.3.html">5.3 协程</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">python SICP 教程</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ul>
<li><a href="#35-%E7%BB%84%E5%90%88%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8">3.5 组合语言的解释器</a>
<ul>
<li><a href="#351-%E8%AE%A1%E7%AE%97%E5%99%A8">3.5.1 计算器</a></li>
<li><a href="#352-%E8%A7%A3%E6%9E%90">3.5.2 解析</a></li>
</ul>
</li>
</ul>
<h1 id="35-组合语言的解释器"><a class="header" href="#35-组合语言的解释器">3.5 组合语言的解释器</a></h1>
<blockquote>
<p>来源：<a href="http://www-inst.eecs.berkeley.edu/%7Ecs61a/sp12/book/interpretation.html#interpreters-for-languages-with-combination">3.5   Interpreters for Languages with Combination</a></p>
<p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p>
</blockquote>
<p>运行在任何现代计算机上的软件都以多种编程语言写成。其中有物理语言，例如用于特定计算机的机器语言。这些语言涉及到基于独立储存位和原始机器指令的数据表示和控制。机器语言的程序员涉及到使用提供的硬件，为资源有限的计算构建系统和功能的高效实现。高阶语言构建在机器语言之上，隐藏了表示为位集的数据，以及表示为原始指令序列的程序的细节。这些语言拥有例如过程定义的组合和抽象的手段，它们适用于组织大规模的软件系统。</p>
<p>元语言抽象 -- 建立了新的语言 -- 并在所有工程设计分支中起到重要作用。它对于计算机编程尤其重要，因为我们不仅仅可以在编程中构想出新的语言，我们也能够通过构建解释器来实现它们。编程语言的解释器是一个函数，它在语言的表达式上调用，执行求解表达式所需的操作。</p>
<p>我们现在已经开始了技术之旅，通过这种技术，编程语言可以建立在其它语言之上。我们首先会为计算器定义解释器，它是一种受限的语言，和 Python 调用表达式具有相同的语法。我们之后会从零开始开发 Scheme 和 Logo 语言的解释器，它们都是 Lisp 的方言，Lisp 是现在仍旧广泛使用的第二老的语言。我们所创建的解释器，在某种意义上，会让我们使用 Logo 编写完全通用的程序。为了这样做，它会实现我们已经在这门课中开发的求值环境模型。</p>
<h2 id="351-计算器"><a class="header" href="#351-计算器">3.5.1 计算器</a></h2>
<p>我们的第一种新语言叫做计算器，一种用于加减乘除的算术运算的表达式语言。计算器拥有 Python 调用表达式的语法，但是它的运算符对于所接受的参数数量更加灵活。例如，计算器运算符<code>mul</code>和<code>add</code>可接受任何数量的参数：</p>
<pre><code class="language-py">calc&gt; add(1, 2, 3, 4)
10
calc&gt; mul()
1
</code></pre>
<p><code>sub</code>运算符拥有两种行为：传入一个运算符，它会对运算符取反。传入至少两个，它会从第一个参数中减掉剩余的参数。<code>div</code>运算符拥有 Python 的<code>operator.truediv</code>的语义，只接受两个参数。</p>
<pre><code class="language-py">calc&gt; sub(10, 1, 2, 3)
4
calc&gt; sub(3)
-3
calc&gt; div(15, 12)
1.25
</code></pre>
<p>就像 Python 中那样，调用表达式的嵌套提供了计算器语言中的组合手段。为了精简符号，我们使用运算符的标准符号来代替名称：</p>
<pre><code class="language-py">calc&gt; sub(100, mul(7, add(8, div(-12, -3))))
16.0
calc&gt; -(100, *(7, +(8, /(-12, -3))))
16.0
</code></pre>
<p>我们会使用 Python 实现计算器解释器。也就是说，我们会编写 Python 程序来接受字符串作为输入，并返回求值结果。如果输入是符合要求的计算器表达式，结果为字符串，反之会产生合适的异常。计算器语言解释器的核心是叫做<code>calc_eval</code>的递归函数，它会求解树形表达式对象。</p>
<p><strong>表达式树。</strong> 到目前为止，我们在描述求值过程中所引用的表达式树，还是概念上的实体。我们从没有显式将表达式树表示为程序中的数据。为了编写解释器，我们必须将表达式当做数据操作。在这一章中，许多我们之前介绍过的概念都会最终以代码实现。</p>
<p>计算器中的基本表达式只是一个数值，类型为<code>int</code>或<code>float</code>。所有复合表达式都是调用表达式。调用表达式表示为拥有两个属性实例的<code>Exp</code>类。计算器的<code>operator</code>总是字符串：算数运算符的名称或符号。<code>operands</code>要么是基本表达式，要么是<code>Exp</code>的实例本身。</p>
<pre><code class="language-py">&gt;&gt;&gt; class Exp(object):
        &quot;&quot;&quot;A call expression in Calculator.&quot;&quot;&quot;
        def __init__(self, operator, operands):
            self.operator = operator
            self.operands = operands
        def __repr__(self):
            return 'Exp({0}, {1})'.format(repr(self.operator), repr(self.operands))
        def __str__(self):
            operand_strs = ', '.join(map(str, self.operands))
            return '{0}({1})'.format(self.operator, operand_strs)
</code></pre>
<p><code>Exp</code>实例定义了两个字符串方法。<code>__repr__</code>方法返回 Python 表达式，而<code>__str__</code>方法返回计算器表达式。</p>
<pre><code class="language-py">&gt;&gt;&gt; Exp('add', [1, 2])
Exp('add', [1, 2])
&gt;&gt;&gt; str(Exp('add', [1, 2]))
'add(1, 2)'
&gt;&gt;&gt; Exp('add', [1, Exp('mul', [2, 3, 4])])
Exp('add', [1, Exp('mul', [2, 3, 4])])
&gt;&gt;&gt; str(Exp('add', [1, Exp('mul', [2, 3, 4])]))
'add(1, mul(2, 3, 4))'
</code></pre>
<p>最后的例子演示了<code>Exp</code>类如何通过包含作为<code>operands</code>元素的<code>Exp</code>的实例，来表示表达式树中的层次结构。</p>
<p><strong>求值。</strong> <code>calc_eval</code>函数接受表达式作为参数，并返回它的值。它根据表达式的形式为表达式分类，并且指导它的求值。对于计算器来说，表达式的两种句法形式是数值或调用表达式，后者是<code>Exp</code>的实例。数值是自求值的，它们可以直接从<code>calc_eval</code>中返回。调用表达式需要使用函数。</p>
<pre><code class="language-py">&gt;&gt;&gt; def calc_eval(exp):
        &quot;&quot;&quot;Evaluate a Calculator expression.&quot;&quot;&quot;
        if type(exp) in (int, float):
            return exp
        elif type(exp) == Exp:
            arguments = list(map(calc_eval, exp.operands))
            return calc_apply(exp.operator, arguments)
</code></pre>
<p>调用表达式首先通过将<code>calc_eval</code>函数递归映射到操作数的列表，计算出参数列表来求值。之后，在第二个函数<code>calc_apply</code>中，运算符会作用于这些参数上。</p>
<p>计算器语言足够简单，我们可以轻易地在单一函数中表达每个运算符的使用逻辑。在<code>calc_apply</code>中，每种条件子句对应一个运算符。</p>
<pre><code class="language-py">&gt;&gt;&gt; from operator import mul
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def calc_apply(operator, args):
        &quot;&quot;&quot;Apply the named operator to a list of args.&quot;&quot;&quot;
        if operator in ('add', '+'):
            return sum(args)
        if operator in ('sub', '-'):
            if len(args) == 0:
                raise TypeError(operator + ' requires at least 1 argument')
            if len(args) == 1:
                return -args[0]
            return sum(args[:1] + [-arg for arg in args[1:]])
        if operator in ('mul', '*'):
            return reduce(mul, args, 1)
        if operator in ('div', '/'):
            if len(args) != 2:
                raise TypeError(operator + ' requires exactly 2 arguments')
            numer, denom = args
            return numer/denom
</code></pre>
<p>上面，每个语句组计算了不同运算符的结果，或者当参数错误时产生合适的<code>TypeError</code>。<code>calc_apply</code>函数可以直接调用，但是必须传入值的列表作为参数，而不是运算符表达式的列表。</p>
<pre><code class="language-py">&gt;&gt;&gt; calc_apply('+', [1, 2, 3])
6
&gt;&gt;&gt; calc_apply('-', [10, 1, 2, 3])
4
&gt;&gt;&gt; calc_apply('*', [])
1
&gt;&gt;&gt; calc_apply('/', [40, 5])
8.0
</code></pre>
<p><code>calc_eval</code>的作用是，执行合适的<code>calc_apply</code>调用，通过首先计算操作数子表达式的值，之后将它们作为参数传入<code>calc_apply</code>。于是，<code>calc_eval</code>可以接受嵌套表达式。</p>
<pre><code class="language-py">&gt;&gt;&gt; e = Exp('add', [2, Exp('mul', [4, 6])])
&gt;&gt;&gt; str(e)
'add(2, mul(4, 6))'
&gt;&gt;&gt; calc_eval(e)
26
</code></pre>
<p><code>calc_eval</code>的结构是个类型（表达式的形式）分发的例子。第一种表达式是数值，不需要任何的额外求值步骤。通常，基本表达式不需要任何额外的求值步骤，这叫做自求值。计算器语言中唯一的自求值表达式就是数值，但是在通用语言中可能也包括字符串、布尔值，以及其它。</p>
<p><strong>“读取-求值-打印”循环。</strong> 和解释器交互的典型方式是“读取-求值-打印”循环（REPL），它是一种交互模式，读取表达式、对其求值，之后为用户打印出结果。Python 交互式会话就是这种循环的例子。</p>
<p>REPL 的实现与所使用的解释器无关。下面的<code>read_eval_print_loop</code>函数使用内建的<code>input</code>函数，从用户接受一行文本作为输入。它使用语言特定的<code>calc_parse</code>函数构建表达式树。<code>calc_parse</code>在随后的解析一节中定义。最后，它打印出对由<code>calc_parse</code>返回的表达式树调用<code>calc_eval</code>的结果。</p>
<pre><code class="language-py">&gt;&gt;&gt; def read_eval_print_loop():
        &quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;
        while True:
            expression_tree = calc_parse(input('calc&gt; '))
            print(calc_eval(expression_tree))
</code></pre>
<p><code>read_eval_print_loop</code>的这个版本包含所有交互式界面的必要组件。一个样例会话可能像这样：</p>
<pre><code class="language-py">calc&gt; mul(1, 2, 3)
6
calc&gt; add()
0
calc&gt; add(2, div(4, 8))
2.5
</code></pre>
<p>这个循环没有实现终端或者错误处理机制。我们可以通过向用户报告错误来改进这个界面。我们也可以允许用户通过发射键盘中断信号（<code>Control-C</code>），或文件末尾信号（<code>Control-D</code>）来退出循环。为了实现这些改进，我们将原始的<code>while</code>语句组放在<code>try</code>语句中。第一个<code>except</code>子句处理了由<code>calc_parse</code>产生的<code>SyntaxError</code>异常，也处理了由<code>calc_eval</code>产生的<code>TypeError</code>和<code>ZeroDivisionError</code>异常。</p>
<pre><code class="language-py">&gt;&gt;&gt; def read_eval_print_loop():
        &quot;&quot;&quot;Run a read-eval-print loop for calculator.&quot;&quot;&quot;
        while True:
            try:
                expression_tree = calc_parse(input('calc&gt; '))
                print(calc_eval(expression_tree))
            except (SyntaxError, TypeError, ZeroDivisionError) as err:
                print(type(err).__name__ + ':', err)
            except (KeyboardInterrupt, EOFError):  # &lt;Control&gt;-D, etc.
                print('Calculation completed.')
                return
</code></pre>
<p>这个循环实现报告错误而不退出循环。发生错误时不退出程序，而是在错误消息之后重新开始循环可以让用户回顾他们的表达式。通过导入<code>readline</code>模块，用户甚至可以使用上箭头或<code>Control-P</code>来回忆他们之前的输入。最终的结果提供了错误信息报告的界面：</p>
<pre><code class="language-py">calc&gt; add
SyntaxError: expected ( after add
calc&gt; div(5)
TypeError: div requires exactly 2 arguments
calc&gt; div(1, 0)
ZeroDivisionError: division by zero
calc&gt; ^DCalculation completed.
</code></pre>
<p>在我们将解释器推广到计算器之外的语言时，我们会看到，<code>read_eval_print_loop</code>由解析函数、求值函数，和由<code>try</code>语句处理的异常类型参数化。除了这些修改之外，任何 REPL 都可以使用相同的结构来实现。</p>
<h2 id="352-解析"><a class="header" href="#352-解析">3.5.2 解析</a></h2>
<p>解析是从原始文本输入生成表达式树的过程。解释这些表达式树是求值函数的任务，但是解析器必须提供符合格式的表达式树给求值器。解析器实际上由两个组件组成，词法分析器和语法分析器。首先，词法分析器将输入字符串拆成标记（token），它们是语言的最小语法单元，就像名称和符号那样。其次，语法分析器从这个标记序列中构建表达式树。</p>
<pre><code class="language-py">&gt;&gt;&gt; def calc_parse(line):
        &quot;&quot;&quot;Parse a line of calculator input and return an expression tree.&quot;&quot;&quot;
        tokens = tokenize(line)
        expression_tree = analyze(tokens)
        if len(tokens) &gt; 0:
            raise SyntaxError('Extra token(s): ' + ' '.join(tokens))
        return expression_tree
</code></pre>
<p>标记序列由叫做<code>tokenize</code>的词法分析器产生，并被叫做<code>analyze</code>语法分析器使用。这里，我们定义了<code>calc_parse</code>，它只接受符合格式的计算器表达式。一些语言的解析器为接受以换行符、分号或空格分隔的多种表达式而设计。我们在引入 Logo 语言之前会推迟实现这种复杂性。</p>
<p><strong>词法分析。</strong> 用于将字符串解释为标记序列的组件叫做分词器（tokenizer ），或者词法分析器。在我们的视线中，分词器是个叫做<code>tokenize</code>的函数。计算器语言由包含数值、运算符名称和运算符类型的符号（比如<code>+</code>）组成。这些符号总是由两种分隔符划分：逗号和圆括号。每个符号本身都是标记，就像每个逗号和圆括号那样。标记可以通过向输入字符串添加空格，之后在每个空格处分割字符串来分开。</p>
<pre><code class="language-py">&gt;&gt;&gt; def tokenize(line):
        &quot;&quot;&quot;Convert a string into a list of tokens.&quot;&quot;&quot;
        spaced = line.replace('(',' ( ').replace(')',' ) ').replace(',', ' , ')
        return spaced.split()
</code></pre>
<p>对符合格式的计算器表达式分词不会损坏名称，但是会分开所有符号和分隔符。</p>
<pre><code class="language-py">&gt;&gt;&gt; tokenize('add(2, mul(4, 6))')
['add', '(', '2', ',', 'mul', '(', '4', ',', '6', ')', ')']
</code></pre>
<p>拥有更加复合语法的语言可能需要更复杂的分词器。特别是，许多分析器会解析每种返回标记的语法类型。例如，计算机中的标记类型可能是运算符、名称、数值或分隔符。这个分类可以简化标记序列的解析。</p>
<p><strong>语法分析。</strong> 将标记序列解释为表达式树的组件叫做语法分析器。在我们的实现中，语法分析由叫做<code>analyze</code>的递归函数完成。它是递归的，因为分析标记序列经常涉及到分析这些表达式树中的标记子序列，它本身作为更大的表达式树的子分支（比如操作数）。递归会生成由求值器使用的层次结构。</p>
<p><code>analyze</code>函数接受标记列表，以符合格式的表达式开始。它会分析第一个标记，将表示数值的字符串强制转换为数字的值。之后要考虑计算机中的两个合法表达式类型。数字标记本身就是完整的基本表达式树。复合表达式以运算符开始，之后是操作数表达式的列表，由圆括号分隔。我们以一个不检查语法错误的实现开始。</p>
<pre><code class="language-py">&gt;&gt;&gt; def analyze(tokens):
        &quot;&quot;&quot;Create a tree of nested lists from a sequence of tokens.&quot;&quot;&quot;
        token = analyze_token(tokens.pop(0))
        if type(token) in (int, float):
            return token
        else:
            tokens.pop(0)  # Remove (
            return Exp(token, analyze_operands(tokens))
&gt;&gt;&gt; def analyze_operands(tokens):
        &quot;&quot;&quot;Read a list of comma-separated operands.&quot;&quot;&quot;
        operands = []
        while tokens[0] != ')':
            if operands:
                tokens.pop(0)  # Remove ,
            operands.append(analyze(tokens))
        tokens.pop(0)  # Remove )
        return operands
</code></pre>
<p>最后，我们需要实现<code>analyze_token</code>。<code>analyze_token</code>函数将数值文本转换为数值。我们并不自己实现这个逻辑，而是依靠内建的 Python 类型转换，使用<code>int</code>和<code>float</code>构造器来将标记转换为这种类型。</p>
<pre><code class="language-py">&gt;&gt;&gt; def analyze_token(token):
        &quot;&quot;&quot;Return the value of token if it can be analyzed as a number, or token.&quot;&quot;&quot;
        try:
            return int(token)
        except (TypeError, ValueError):
            try:
                return float(token)
            except (TypeError, ValueError):
                return token
</code></pre>
<p>我们的<code>analyze</code>实现就完成了。它能够正确将符合格式的计算器表达式解析为表达式树。这些树由<code>str</code>函数转换回计算器表达式。</p>
<pre><code class="language-py">&gt;&gt;&gt; expression = 'add(2, mul(4, 6))'
&gt;&gt;&gt; analyze(tokenize(expression))
Exp('add', [2, Exp('mul', [4, 6])])
&gt;&gt;&gt; str(analyze(tokenize(expression)))
'add(2, mul(4, 6))'
</code></pre>
<p><code>analyze</code>函数只会返回符合格式的表达式树，并且它必须检测输入中的语法错误。特别是，它必须检测表达式是否完整、正确分隔，以及只含有已知的运算符。下面的修订版本确保了语法分析的每一步都找到了预期的标记。</p>
<pre><code class="language-py">&gt;&gt;&gt; known_operators = ['add', 'sub', 'mul', 'div', '+', '-', '*', '/']
&gt;&gt;&gt; def analyze(tokens):
        &quot;&quot;&quot;Create a tree of nested lists from a sequence of tokens.&quot;&quot;&quot;
        assert_non_empty(tokens)
        token = analyze_token(tokens.pop(0))
        if type(token) in (int, float):
            return token
        if token in known_operators:
            if len(tokens) == 0 or tokens.pop(0) != '(':
                raise SyntaxError('expected ( after ' + token)
            return Exp(token, analyze_operands(tokens))
        else:
            raise SyntaxError('unexpected ' + token)
&gt;&gt;&gt; def analyze_operands(tokens):
        &quot;&quot;&quot;Analyze a sequence of comma-separated operands.&quot;&quot;&quot;
        assert_non_empty(tokens)
        operands = []
        while tokens[0] != ')':
            if operands and tokens.pop(0) != ',':
                raise SyntaxError('expected ,')
            operands.append(analyze(tokens))
            assert_non_empty(tokens)
        tokens.pop(0)  # Remove )
        return elements
&gt;&gt;&gt; def assert_non_empty(tokens):
        &quot;&quot;&quot;Raise an exception if tokens is empty.&quot;&quot;&quot;
        if len(tokens) == 0:
            raise SyntaxError('unexpected end of line')
</code></pre>
<p>信息丰富的语法错误在本质上提升了解释器的可用性。在上面，<code>SyntaxError</code>异常包含所发生的问题描述。这些错误字符串也用作这些分析函数的定义文档。</p>
<p>这个定义完成了我们的计算器解释器。你可以获取单独的 Python 3 源码 <a href="http://www-inst.eecs.berkeley.edu/%7Ecs61a/sp12/book/calc.py"><code>calc.py</code></a>来测试。我们的解释器对错误的处理能力很强，用户在<code>calc&gt;</code>提示符后面的每个输入都会求值为数值，或者产生合适的错误，描述输入为什么不是符合格式的计算器表达式。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="3.4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="3.6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="3.4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="3.6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

                <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
